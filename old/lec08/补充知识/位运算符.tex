\documentclass[10pt,a4paper%,twoside,openright,titlepage,fleqn,%
%headinclude,footinclude,BCOR5mm,%
%numbers=noenddot,cleardoublepage=empty,%
tablecaptionabove]{article}

\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}

\usepackage{amsmath,amssymb,amsthm}

%% -----------------设置数学公式字体-------------------------
%% Font style 1
%% \newcommand\ibinom[2]{\genfrac\lbrace\rbrace{0pt}{}{#1}{#2}}
%% \usepackage{bm}

%% Font style 2
%% \newcommand\ibinom[2]{\genfrac\lbrace\rbrace{0pt}{}{#1}{#2}} 
%% \usepackage[boldsans]{ccfonts} 
%% \usepackage{bm} 

%% Font style 3
\newcommand\ibinom[2]{\genfrac\lbrace\rbrace{0pt}{}{#1}{#2}}
\usepackage[euler-digits]{eulervm}
\usepackage{bm}

%% Font style 4
%% \usepackage{fourier}
%% \newcommand\ibinom[2]{\genfrac\lbrace\rbrace{0pt}{}{#1}{#2}}
%% \usepackage{bm}

%% Font style 5
%% \newcommand\ibinom[2]{\genfrac\lbrace\rbrace{0pt}{}{#1}{#2}}
%% \usepackage{mathptmx}
%% \usepackage{bm} 


%% %% Font style 6
%% \newcommand\ibinom[2]{\genfrac\lbrace\rbrace{0pt}{}{#1}{#2}}
%% \usepackage{txfonts}
%% \usepackage{bm}
%% -----------------------------------------------------------

\usepackage{titlesec} %设置标题
\usepackage{titletoc}

\usepackage{extarrows}
\usepackage{verbatim,color,xcolor}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,snakes,backgrounds,shapes,patterns}
\usetikzlibrary{matrix,fit,positioning,decorations.pathmorphing}
%% \usepackage{classicthesis}
\usepackage{CJK}
\usepackage{mathdots}

\usepackage{listings}
\lstset{
  keywordstyle=\color{blue!70},
  frame=single,
  basicstyle=\ttfamily\small,
  commentstyle=\small\color{red},
  breakindent=0pt,
  rulesepcolor=\color{red!20!green!20!blue!20},
  rulecolor=\color{black},
  tabsize=4,
  numbersep=5pt,
  breaklines=true,
  %% backgroundcolor=\color{red!10},
  showspaces=false,
  showtabs=false,
  extendedchars=false,
  escapeinside=``,
  frame=no,
}


\newcommand{\blue}{\textcolor{blue}}
\newcommand{\red}{\textcolor{red}}
\newcommand{\purple}{\textcolor{electricpurple}}
\newcommand{\ds}{\displaystyle}
\newcommand{\cd}{\cdots}
\newcommand{\dd}{\ddots}
\newcommand{\vd}{\vdots}
\newcommand{\id}{\iddots}

\newcommand{\R}{\mathbb R}
\def\nn{{\boldsymbol{n}}}
\def\xx{{\boldsymbol{x}}}
\def\F{{\boldsymbol{F}}}
\def\div{{\mathrm{div}}}
\def\tf{\ttfamily}


\begin{document}

\begin{CJK}{UTF8}{gkai}
 

\newtheorem{li}{例}
\newtheorem{jielun}{结论}
\newtheorem{dingli}{定理}
\newtheorem{mingti}{{命题}} 
\newtheorem{yinli}{{引理}} 
\newtheorem{tuilun}{{推论}}
\newtheorem{dingyi}{{定义}} 
\newtheorem{example}{{例}}
\newtheorem*{example*}{{例}}
\newtheorem*{jie}{{解}}
\newtheorem*{zhengming}{{证明}}
\newtheorem{zhu}{{注}}
\newtheorem*{zhu*}{{注}}
\newtheorem{xingzhi}{{性质}}
\newtheorem{wenti}{{问题}}
\newtheorem{rem}{{Remark}}
\newtheorem{lem}{{Lemma}}
\pagenumbering{roman}
\pagestyle{plain}

\pagenumbering{arabic}

\title{位运算符}
%\author{张晓平}
%\date{}                                           % Activate to display a given date or no date
\maketitle

在C中，有如下6种位运算符：
\begin{enumerate}
\item 位与 { \tf \&} ：若两位都是1，返回结果1。
\item 位或 { \tf |} ：若至少有一位为1，则返回结果1。
\item 位异或 { \tf \^{}} ：若两位不同，则返回结果1。
\item 左移 {\tf <<}：
\item 右移 {\tf >>}：
%% ^ (bitwise XOR) Takes two numbers as operand and does XOR on every bit of two numbers. The result of XOR is 1 if the two bits are different.

%% << (left shift) Takes two numbers, left shifts the bits of first operand, the second operand decides the number of places to shift.

%% >> (right shift) Takes two numbers, right shifts the bits of first operand, the second operand decides the number of places to shift.

%% ~ (bitwise NOT) Takes one number and inverts all bits of it

\end{enumerate}

%% Following is example C program.

%% /* C Program to demonstrate use of bitwise operators */
%% #include<stdio.h>
%% int main()
%% {
%%     unsigned char a = 5, b = 9; // a = 4(00000101), b = 8(00001001)
%%     printf("a = %d, b = %d\n", a, b);
%%     printf("a&b = %d\n", a&b); // The result is 00000001
%%     printf("a|b = %d\n", a|b);  // The result is 00001101
%%     printf("a^b = %d\n", a^b); // The result is 00001100
%%     printf("~a = %d\n", a = ~a);   // The result is 11111010
%%     printf("b<<1 = %d\n", b<<1);  // The result is 00010010 
%%     printf("b>>1 = %d\n", b>>1);  // The result is 00000100 
%%     return 0;
%% }
%% Run on IDE
%% Output:

%% a = 5, b = 9
%% a&b = 1
%% a|b = 13
%% a^b = 12
%% ~a = 250
%% b<<1 = 18
%% b>>1 = 4
%% Following are interesting facts about bitwise operators.

%% 1) The left shift and right shift operators should not be used for negative numbers The result of << and >> is undefined behabiour if any of the operands is a negative number. For example results of both -1 << 1 and 1 << -1 is undefined. Also, if the number is shifted more than the size of integer, the behaviour is undefined. For example, 1 << 33 is undefined if integers are stored using 32 bits. See this for more details.

%% 2) The bitwise XOR operator is the most useful operator from technical interview perspective. It is used in many problems. A simple example could be “Given a set of numbers where all elements occur even number of times except one number, find the odd occuring number” This problem can be efficiently solved by just doing XOR of all numbers.

%% // Function to return the only odd occurring element
%% int findOdd(int arr[], int n) {
%%    int res = 0, i;
%%    for (i = 0; i < n; i++)
%%      res ^= arr[i];
%%    return res;
%% }
 
%% int main(void) {
%%    int arr[] = {12, 12, 14, 90, 14, 14, 14};
%%    int n = sizeof(arr)/sizeof(arr[0]);
%%    printf ("The odd occurring element is %d ", findOdd(arr, n));
%%    return 0;
%% }
%% // Output: The odd occurring element is 90
%% Run on IDE
%% The following are many other interesting problems which can be used using XOR operator.
%% Find the Missing Number, swap two numbers without using a temporary variable, A Memory Efficient Doubly Linked List, and Find the two non-repeating elements. There are many more (See this, this, this, this, this and this)

%% 3) The bitwise operators should not be used in-place of logical operators.
%% The result of logical operators (&&, || and !) is either 0 or 1, but bitwise operators return an integer value. Also, the logical operators consider any non-zero operand as 1. For example consider the following program, the results of & and && are different for same operands.

%% int main()
%% {
%%    int x = 2, y = 5;
%%    (x & y)? printf("True ") : printf("False ");
%%    (x && y)? printf("True ") : printf("False ");
%%    return 0;
%% }
%% // Output: False True
%% Run on IDE
%% 4) The left-shift and right-shift operators are equivalent to multiplication and division by 2 respectively.
%% As mentioned in point 1, it works only if numbers are positive.

%% int main()
%% {
%%    int x = 19;
%%    printf ("x << 1 = %d\n", x << 1);
%%    printf ("x >> 1 = %d\n", x >> 1);
%%    return 0;
%% }
%% // Output: 38 9
%% Run on IDE
%% 5) The & operator can be used to quickly check if a number is odd or even
%% The value of expression (x & 1) would be non-zero only if x is odd, otherwise the value would be zero.

%% int main()
%% {
%%    int x = 19;
%%    (x & 1)? printf("Odd"): printf("Even");
%%    return 0;
%% }
%% // Output: Odd
%% Run on IDE
%% 6) The ~ operator should be used carefully
%% The result of ~ operator on a small number can be a big number if result is stored in a unsigned variable. And result may be negative number if result is stored in signed variable (assuming that the negative numbers are stored in 2’s complement form where leftmost bit is the sign bit)

%% // Note that the output of following program is compiler dependent
%% int main()
%% {
%%    unsigned int x = 1;
%%    printf("Signed Result %d \n", ~x);
%%    printf("Unsigned Result %ud \n", ~x);
%%    return 0;
%% }
%% /* Output: 
%% Signed Result -2 
%% Unsigned Result 4294967294d */

\end{CJK}
\end{document}
