\section{指向结构的指针}
\begin{frame}[fragile]\ft{\secname}
为什么要使用指向结构的指针，有以下三个原因：

\begin{enumerate}
\item 如同指向数组的指针比数组本身更容易操作一样，指向结构的指针通常比结构本身更容易操作；
\item 在一些早期的C实现中，结构不能作为参数被传递给函数，但指向结构的指针可以；
\item 许多奇妙的数据表示都使用了包含指向其他结构的指针的结构。
\end{enumerate}
\end{frame}

\subsection{声明和初始化结构指针}
\begin{frame}[fragile]\ft{\subsecname}
  声明如下：
    \begin{lstlisting}[language=c,backgroundcolor=\color{red!20}]
struct guy * him;
    \end{lstlisting}
该声明意味着指针{\tf him}现在可以指向任意{\tf guy}类型的结构。如果{\tf barney}是一个{\tf guy}类型的结构，可以这样做
    \begin{lstlisting}[language=c,backgroundcolor=\color{red!20}]
him = &barney;
    \end{lstlisting}
请注意：\textcolor{acolor1}{和数组不同，一个结构的名字不是该结构的地址，必须使用{\tf \&}运算符。}
\end{frame}

\begin{frame}[fragile]\ft{\subsecname}
  {\tf fellow}是一个结构数组，亦即{\tf fellow[0]}是一个结构，以下代码让{\tf him}指向{\tf fellow[0]}：
    \begin{lstlisting}[language=c,backgroundcolor=\color{red!20}]
him = &fellow[0];
    \end{lstlisting}

\end{frame}

\subsection{使用指针访问结构成员}
\begin{frame}[fragile]\ft{\subsecname}
假设{\tf him}现在指向{\tf fellow[0]}，有两种方式来访问它的成员：
\begin{enumerate}
\item 使用运算符：{\tf ->}。
    \begin{lstlisting}[language=c,backgroundcolor=\color{red!20}]
him->income is fellow[0].income 
if him == &fellow[0]
    \end{lstlisting}
务必注意{\tf him}是个指针，而{\tf him->income}是{\tf him}所指向结构的一个成员。
\item 使用点运算符。
      \begin{lstlisting}[language=c,backgroundcolor=\color{red!20}]
fellow[0].income  == (*him).income
    \end{lstlisting}
必须使用圆括号，因点运算符的优先级比{\tf *}更高。
\end{enumerate}
\end{frame}

\begin{frame}[fragile]\ft{\subsecname}
假设{\tf him}现在指向{\tf fellow[0]}，则以下表达式等价
\begin{lstlisting}[language=c,backgroundcolor=\color{red!20}]
fellow[0].income  == (*him).income 
                  == him->income
\end{lstlisting}
\end{frame}
